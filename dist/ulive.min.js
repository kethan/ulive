let e,t;const l=e=>(e.toJSON=e.then=e.toString=e.valueOf=()=>e.value,e),f=(f,n,r=new Set)=>l({get value(){return e?.t.push(r.add(e)),f},set value(e){if(e!==f){f=e;for(let e of r)t?t.add(e):e()}},l:()=>f}),n=(t,l,f,n)=>(n=(f=n=>{l?.call?.(),n=e,e=f;try{l=t()}finally{e=n}}).t=[],f(),e=>{for(l?.call?.();e=n.pop();)e.delete(f)});var r={signal:f,effect:n,computed:(e,t=f(),r,a)=>l({get value(){return a||=n((()=>t.value=e())),t.value},l:t.l}),batch:e=>{let l=t;l||(t=new Set);try{e()}finally{if(!l){l=t,t=null;for(const e of l)e()}}},untracked:(t,l,f)=>(l=e,e=null,f=t(),e=l,f)};self.ulive=r;