let e,t;const l=(l,f,n=new Set)=>((f={get value(){return e?.t.push(n.add(e)),l},set value(e){if(e!==l){l=e;for(let e of n)t?t.add(e):e()}},l:()=>l}).toJSON=f.then=f.toString=f.valueOf=()=>f.value,f),f=(t,l,f,n)=>(n=(f=n=>{l?.call?.(),n=e,e=f;try{l=t()}finally{e=n}}).t=[],f(),e=>{for(l?.call?.();e=n.pop();)e.delete(f)});var n={batch:e=>{let l=t;l||(t=new Set);try{e()}finally{if(!l){l=t,t=null;for(const e of l)e()}}},computed:(e,t=l(),n,r)=>((n={get value(){return r||=f((()=>t.value=e())),t.value},l:t.l}).toJSON=n.then=n.toString=n.valueOf=()=>n.value,n),effect:f,signal:l,untracked:(t,l,f)=>(l=e,e=null,f=t(),e=l,f)};self.ulive=n;